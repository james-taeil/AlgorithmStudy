```
처음에는 조금 무식한 방법을 썼다. 
1 부터 주어진 사람 수 까지를 요소들과 전부 곱해서 배열을 만든 다음 정렬시켜서 
n 번째 요소를 찾으면 답이 나오는 방식이다. 
3, [1,2,3,4] 가 주어지면 
//1* times / 2*times/ 3*times 
[1,2,3,4,  2,4,6,8,  3,6,9,12] 정렬
[1,2,2,3,3,4,4,... ] 이렇게 되는 데 3번째 요소는 2번 인덱스에 있으니 
배열[n-1] => 배열[3-1] = 2 가 된다. 
결과적으로 심사자는 1번 2번 그리고 한번 기다려서 1번에 갈 것 이므로 정답과 일치한다.

6, [7,10] 의 경우도 보자 
[7,10  ,14,20  ,21,30 , 28, 40, 35, 50,  42, 60]
정렬
[7,  10,  14,  20,  21,  28,  30,35,40]
                         6-1                                

```

function solution(n, times) {
    var answer = 0;
    let arr =[]  // 배열을 할당
   for(let i=1; i<=n; i++){ // 1 부터 n까지의 수를 곱한 배열을 만든다.  
       times.map(el=>{    
           arr.push(el*i)
       })
   }
    arr.sort((a,b)=>a-b) // 정렬 시키고 

    
    return arr[n-1]; // n-1 번째 인덱스를 찾아 준다.
}

```
이분 탐색을 사용한 코드 
어떻게 이분 탐색을 하는 지 이해하는 데 시각이 좀 걸렸다. 

위에 쓴 부분과 어느 정도 일치하는 부분이 있어서 재미있었다.
우선 최대값을 구하고 (위에서 보면 배열의 마지막 요소)
중간 값을 구한 다음 각 요소로 나눈 값이 입국 심사대 이용횟수와 같다 

그러니까 이와 같은 임이의 배열이 있다고 하자 
[7,10 ,14,20 ,21,30, 28, 40, 35, 50, 42, 60]
여기엔 규칙이 있다. 1,2,3,4,5,6 과 7,10 의 곱이라는 것 
1- 7,10,
2- 14,20,
3- 21,30, 
4- 28, 40, 
5- 35, 50, 
6- 42, 60
최댓값은 60 이다 아래의 right 과 같다 
정답인 28을 보자 28 나누기 7은 4 / 28 나누기 10은 2이다 
이 결과를 합친 값은 6이므로 입국심사 인원 수와 같다.

아래의 코드는 이와 같은 규칙을 이용한 것이다. 
가상의 배열이 있다고 생각하고 그 배열을 이분 탐색하는 것이라 볼 수 있다. 


```
function solution(n, times) {
    times.sort((a,b)=>a-b) // 최댓값을 구하기 위한 정렬 
    let left = 0
    let right =times[times.length-1]*n // n* 최댓값은 일어날 수 있는 입국심사에 걸리는 가장 긴 시간 

    let sum = 0 // 입국심사가 횟수 
    while(left<=right){ // 요소가 하나 남을 때 까지 
        let mid = Math.floor((left+right)/2) // 중간 값을 구하고 
        sum = times.reduce((a,b)=>a += Math.floor(mid/b),0) // 그 값을 나눈 수를 더 해서 입국심사 횟수를 구한다. 
        
        if(sum >=n){  
            right = mid-1 // 너무 많이 심사가 발생하면 최댓 값을 중간으로 옮김
        }else if(sum<n){ // 너무 적게 발생하면 최솟값을 중간으로 옮기 면서 반복 
            left = mid+1
        }
        
    }
    return left
   
}